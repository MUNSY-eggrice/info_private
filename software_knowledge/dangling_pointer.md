## 댕글링 포인터에 대해
## 댕글링 포인터(Dangling Pointer)

포인터가 여전히 해제된 메모리 영역을 가리키고 있다면

이러한 포인터를 댕글링 포인터라고 한다.

이 포인터가 가리키는 메모리는 더는 유효하지 않다.

이 포인터는 premature free(조숙한 해제, 급한 해제)라고 부르기도 한다.

아래와 같은 오류를 야기한다.

-메모리 접근시 예측 불가능한 동작

-메모리 접근 불가 시 Segmentation fault

-잠재적인 보안 위험

댕글링 포인터는 다음과 같은 동작의 결과로 발생한다

-메모리 해제 후, 해제된 메모리에 접근

-함수 호출에서 자동 변수를 가리키는 포인터의 반환

예시)

```c
**int * pi = (int * )malloc(sizeof(int)); 
*pi = 5; 
printf("*pi: %d\n", *pi); free(pi);

출처: https://thinkpro.tistory.com/67 [THINK-PRO BLOG]**
```

pi 포인터에 할당된 메모리영역을 free로 해제 한 후에도 여전히

pi는 메모리의 주소를 가리키고 있다.

free된 메모리 영역은 기존의 정수가 아닌 다른 타입으로 사용될 수도 있다.

free함수를 호츌하면 원래 pi포인터가 가리키고 있던 주소에 위치한 메모리는 해제되어 다시는 사용할 수 없다. 그러나 대부분 런타임 시스템에서 해제 뒤에 발생하는 메모리의 접근이나 변경을 막지 않는다. 

다음과 같이 여전히 메모리에 접근해 쓰기를 시도할 수 있으며, 이러한 시도의 결과는 예측할 수 없다.

```c
*pi = 10;
```

하나 이상의 포인터가 같은 메모리 영역을 가리키고 그 중 하나가 해제된 경우에는 좀 더 복잡하다.

이러한 상황을 포인터 에일리어싱(Aliasing)이라고 한다.

```c
int * p1 = (int *)malloc(sizeof(int)); 
*p1 = 5; ... 
int * p2; 
p2 = p1; ... 
free(p1); ... 
*p2 = 10; // p2는 댕글링 포인터이다.

출처: https://thinkpro.tistory.com/67 [THINK-PRO BLOG]
```

또 다른 예제가 있다. 아래 코드와 같이 블록 구문 사용시도 문제가 발생한다.

```c
int *pi; ... 
{ int tmp = 5; pi = &tmp; } // 이 위치에서 pi는 댕글링 포인터가 된다. 
foo();

출처: https://thinkpro.tistory.com/67 [THINK-PRO BLOG]
```

블록 구문은 대부분의 컴파일러에서 스택 프레임으로 다룬다.

tmp는 블록 안의 스택 프레임에 할당되며, 블록 구문이 종료되면

스택 프레임이 제거된다.

블록의 스택프레임으로 사용된 메모리 영역은 나중에 다른 방식으로 재사용되지만 pi가 여전히 그위치를 가리키고 있어 댕글링 포인터에 해당된다.

댕글링 포인터 다루기)

메모리 해제 후 포인터를 null로 설정한다.

그러니 해당 포인터에 대한 다수의 복사본이 존재하는 경우

문제가 여전히 발생한다. 

해당 포인터에 null을 설정하는 일은 그 포인터에만 영향을 미치게 때문이다.

free함수를 대체할 새로운 함수를 작성하라

몇몇 런타임 시스템이나 디버깅 시스템은 해제된 메모리를 특별한 값으로 덮어쓴다.

또는 서드파티 도구들을 사용한다.