# 자료형의 변환

char형으로 표현되어 있는 데이터의 표현방식을 int형으로 바꾸거나, int형 데이터를 double형으로 바꾸는 것이  
자료형의 변환이다.

즉 **자료형의 변환이라는 것은 데이터의 표현방식을 바꾸는 것이다.** 

이러한 자료형의 변환은 다음과 같이 크게 두 종류로 나뉜다.
* 자동 형 변환(묵시적 형 변환)
* 강제 형 변환(명시적 형 변환)

## 대입연산 전달과정에서 발생하는 자동 형 변환

대입 연산자의 왼편과 오른편에 존재하는 두 피연산자의 자료형이 일치하지 않으면, 왼편에 있는 피 연산자를 대상으로 형 변환이 자동으로 일어난다.  
당연하겠지만 저장소의 자료형의 맞춰 형 변환이 일어나야 값의 저장이 가능하기 때문이다.

다음 문장을 보자

```
    double num = 245;
```
이 경우 대입 연산자의 왼편에 있는 num1은 double이지만 245는 int형이다. 따라서 정수형 245은 double형 245.0으로
형변환이 되어 num1에 저장된다.

```
    int num2 = 3.1415;
```
이 경우는 double형이 int형으로 변환되어 들어간다. 그런데 int형으로는 소수점 이하의 값을 표현할 수 없으므로, 형변환 과정에서  
3.1415가 3으로 변환되어 소수부의 손실이 발생한다.  

다음과 같은 경우는 어떻게 형 변환이 진행될까?
```
    int num3 = 129;
    char ch = num3;
```

129가 저장된 변수 num3의 비트열은 다음과 같다.
```
00000000 00000000 00000000 10000001
```

이 데이터를 변수 ch에 저장하기 위해서는 1바이트크기로 줄여야 한다.  
따라서 이 경우에는 **상위 바이트의 손실**이 발생한다.

```
10000001 //음수 이므로 2의 보수를 취하면 01111111, 즉 -127을 의미한다.
```

이렇듯 상위 바이트의 손실로 인해 부호가 바뀌는 경우도 있으니 주의해야한다.

대표적인 형변환을 정리하면 다음과 같다.

1. 정수를 실수로 형 변환하는 경우
    실수의 표현범위가 정수에 비해 넓기 때문에 데이터의 손실은 일어나지 않는다. 다만, 실수이기때문에 오차는 존재한다.
2. 실수를 정수로 형 변환하는 경우
    정수는 소수점 이하를 표현하지 못하기 때문에, 소수점 이하의 값은 버려진다.
3. 바이트가 큰 정수를 바이트가 작은 정수로 형 변환하는 경우
    변환하고자 하는 정수의 바이트 크기에 맞춰 상위 바이트를 단순 소멸시킨다. 이로인해 부호가 바뀔 수 있다.

## 정수의 승격(Integral Promotion)에 의한 자동 형 변환

앞서 다음과 같이 설명한바 있다.

**"일반적으로 CPU가 처리하기 가장 적합한 크기의 정수 자료형을 int로 정의한다. int형 연산의 속도는 다른 자료형의 연산속도에 비해 동일하거나 빠르다."**

따라서 int보다 작은 크기의 정수형 데이터는 int형으로 변환이 되어 연산이 진행된다고 했다.  
다음과 같은 경우에도 int형으로 자동 형 변환이 발생한다.  
```
    short num1 = 15, num2 = 25;
    short num3 = num1 + num2; //num1, num2가 int로 형 변환
```
