# 비트 연산자

비트 연산자에 대해 소개해보겠다.  
비트 단위로 연산을 진행하는 비트연산자는 주로 하드웨어 관련 프로그래밍에 활용되지만, 그 의외의 영역에서도 사용되어  
메모리 공간의 효율성을 높으고 연산의 수를 줄이는 요인이 되기도 한다. 
<br>
연산자의 활용적 측면을 지금 이해하기엔 부담이 따르므로 기능을 설명하도록하겠다.


|연산자|연산자의기능|결합방향
|:--|:--|:--|
|&|비트단위 AND연산 num1 & num2|->|
|^|비트단위 XOR연산 num1 ^ num2|->|
|\||비트단위 OR연산 num1 \| num2|->|
|~|단항 연산자로서 피연산자의 모든 비트를 반전시킨다. ~num <br> num은 변화없음. 반전 결과만 반환.|<-|
|<<|피연산자의 비트열을 왼쪽으로 이동 num<<2 <br> num은 변화없음. 이동 결과만 반환.|->|
|>>|피연산자의 비트열을 오른쪽으로 비트이동 num>>2 <br> num은 변화없음. 이동 결과만 반환.|->|

<<와 >>연산자는 비트 이동 연산자(Shift)연산자라고해서 비트 연산자와는 그 성향이 조금 다르다.  
하지만 흔히 비트연산자 범주에 포함시키므로 함께 정리하였다.

### 비트단위  AND &연산자

& 연산은 두 개의 비트가 모두 1일 때 1을 반환하는 연산이다.
따라서 & 연산자의 비트단위 연산의 결과는 다음과 같다.
```
0 & 0 = 0
0 & 1 = 0
1 & 0 = 0
1 & 1 = 1

num1 = 15; // 00000000 00000000 00000000 00001111
num2 = 20; // 00000000 00000000 00000000 00010100

num1 & num2; // 00000000 00000000 00000000 00000100 = 정수 4
```

### 비트단위  OR \| 연산자

| 연산은 둘 중 하나라도 1일 때 1을 반환하는 연산이다.
따라서 | 연산자의 비트단위 연산의 결과는 다음과 같다.
```
0 | 0 = 0
0 | 1 = 1
1 | 0 = 1
1 | 1 = 1

num1 = 15; // 00000000 00000000 00000000 00001111
num2 = 20; // 00000000 00000000 00000000 00010100

num1 & num2; // 00000000 00000000 00000000 00011111 = 정수 31
```
### 비트단위  XOR ^ 연산자

^ 연산은 두 비트가 서로 다를 때 1을 반환하는 연산이다.
따라서 다음의 결과를 보인다.
```
0 ^ 0 = 0
0 ^ 1 = 1
1 ^ 0 = 1
1 ^ 1 = 0

num1 = 15; // 00000000 00000000 00000000 00001111
num2 = 20; // 00000000 00000000 00000000 00010100

num1 & num2; // 00000000 00000000 00000000 00011011 = 정수 27
```
### 비트단위  NOT ~ 연산자

~  연산은 0을 1로, 1을 0으로 반전시키기 때문에 보수연산이라고도 불린다.
```
0 ^ 0 = 0
0 ^ 1 = 1
1 ^ 0 = 1
1 ^ 1 = 0

num1 = 15; // 00000000 00000000 00000000 00001111
num2 = ~num1; // 11111111 11111111 11111111 11110000
```

*음의 정수 크기 확인하기.  
음의 정수는 양의 정수와 달리 크기를 확인하기 쉽지 않다. 그래서 2의 보수를 취해 크기를 확인해야 한다.
```
1111111 11111111 11111111 11110000 // -16

-2의 보수를 취함

0000000 00000000 00000000 00010000 // 16
```
이를 통해  2의 보수를 취하는 것이 -1을 곱하는 결과 이어진다는 것을 알 수 있다.

### << 연산자, 비트의 왼쪽 이동 (shift)

num1 << num2  num1의 비트열을 num2칸씩 왼쪽으로 이동시킨 결과를 반환.
8 << 2 정수 8의 비트 열을 2칸씩 왼쪽으로 이동시킨 결과를 반환

```
num = 2; // 00000000 00000000 00000000 00000010
result = num<<1; // 00000000 00000000 00000000 00000100 = 정수 4
```
비트의 이동으로 인해서 생기는 오른쪽 빈칸은 0으로 채워지고, 이동으로 인해 밀려나는 왼쪽비트(4바이트를 넘어서는 비트)그냥 버려진다.  
위 예제의 결과로 다음 사실을 알 수 있다.  
*비트의 열을 왼쪽으로 1칸씩 이동시킬 때마다 정수의 값은 두 배가 된다.*  
*비트의 열을 오른쪽으로 1칸씩 이동시킬 때마다 정수의 값은 2로 나누어진다.*  

이 사실을 기억하면 상황에 따라 곱셈과 나눗셈 연산은 비트의 이동 연산으로 대체할 수 있으며, 이는 성능 향상으로 이어진다.
CPU입장에서는 곱셈과 나눗셈이 비트의 이동보다 부담스러운 연산이기 때문이다.

### >> 연산자, 비트의 오른쪽 이동 (shift)

num1 >> num2  num1의 비트열을 num2칸씩 오른쪽으로 이동시킨 결과를 반환.  

다만 MSB가 0이라면 이동으로 인해 밀려나는 오른쪽 비트들은 소멸되고, 왼쪽의 빈자리는 0으로 채워진다. 그러나 MSB 1, 즉 음수였다면 좀 다르다.  

그 결과는 CPU에 따라 달라지는데, 음의 값을 유지하기 위해 1을 채우는 CPU도 있고, 음의 값을 신경쓰지 않고 0을 채우는 CPU도 존재한다.
