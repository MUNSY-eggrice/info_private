# c언어가 제공하는 기본 자료형의 이해

자료형은 데이터를 표현하는 방법이다.  
변수는 데이터의 저장을 위해서 할당된 메모리 공간에 붙여진 이름이다.  
그런데 메모리 공간의 할당에 앞서 어떤 데이터를 저장할 것인지 결정되어야한다.

정수와 실수의 저장방식이 근본적으로 다름을 앞서 확인했다.  
따라서 메모리 공간을 할당할 때 그 용도가 결정되어야 한다.  


정수를 저장하기로 결정했다고 해보자, 정수는 몇 바이트를 사용하건 저장이 가능하다.
다만 바이트의 크기가 크면 클수록 저장할 수있는 정수의 크기가 커질뿐이다.

*"정수를 저장할 것이고, 크기는 4바이트"*

라는 문장을 의미하는 것이 바로 키워드 int 이다.

즉 자료형은 데이터를 표현하는 방법을 뜻한다.

C언어는 여러가지의 자료형을 정의하고 있다. 기본적으로 제공되는 자료형을 가리켜 기본자료형이라고하며, 그 종류는 다음과 같다.

### 정수형
|자료형|크기|표현범위|
|:--|:--|:--|
|char| 1 Byte | -128 ~ +127 |
|short| 2 Byte | -32,768 ~ +32,767|
|int| 4 Byte | -2,148,473,648 ~ +2,148,473,647 |
|long| 4 Byte | -2,148,473,648 ~ +2,148,473,647 |
|long long| 8 Byte | -9,223,372,036,854,775,808 ~ +9,223,372,036,854,775,807

## 실수형
|자료형|크기|표현범위|
|:--|:--|:--|
|float| 4 Byte |+- 3.4 x 10<sup>-37</sup> ~ +-3.4 x 10<sup>+38</sup>|
|double| 8 Byte | +-1.7 x 10<sup>-307</sup> ~ +-1.7 x 10<sup>+308</sup>|
|long double| 8 Byte 이상 | double 이상의 표현범위|

같은 정수 자료형이라고 하더라도 표현에 사용되는 바이트 크기가 클수록  
표현할 수 있는 값의 범위가 넓어짐을 알 수 있다.

C의 표준을 정하는 ANSI에서는 다음과 같은 정로만 자료형의 크기를 표준화하고있다.

**"short와 int는 최소 2바이트이되, int는 short와 크기가 같거나 더 커야한다."**

즉 **자료형의 크기를 정확히 제한하고 있지 않다.** 따라서 자료형 별 크기는 컴파일러마다 차이를 보인다.

많은 수의 자료형이 필요한 이유는 무엇일까? 다음과 같은 이유를 들 수 있다.
1. 데이터의 표현방식이 다르다 (정수, 실수)
2. 메모리 공간의 적절한 사용이 필요하다(500개의 정수를 사용할건데  int형은 낭비다. short로 저장.)

연산자 sizeof를 이용하면 자료형의 크기를 확인할 수 있다.
메모리 공간에서 소모하는 메모리의 크기를 바이트 단위로 계산해서 반환하는 연산자인데,

피 연산자로는 변수와 상수뿐만 아니라, 자료형의 이름도 올 수 있다.  
이를 통해 자신의 컴파일러의 자료형 별 바이트 크기도 확인할 수 있다.

```
sizeof(num)
sizeof(int)

sizeof num //sizeof는 함수가 아니라 연산자 이기때문에 int같은 자료형의 이름들을 제외하면 ()괄호가 필수는 아니다.
```
*sizeof 는 함수가 아니라 연산자라는 점을 기억하자.

## 정수를 표현 및 처리하기 위한 일반적인 자료형의 선택.

그렇다면 상황에 따라 어떤 자료형을 선택하는 것이 좋을까?

먼저 '정수형 데이터를 처리하는 경우'에 대해서 이야기해보자.

정수를 저장할 변수의 자료형을 선택할 때 가장 먼저 생각할 문제는 저자앟고자 하는 값의 범위이다.

만약 저장하고자 하는 정수의 범위가 -32768~+32767 사이에 있다면 short형 변수를 쓰는 것이 더 효율적인 것일까?

이 질문에 대한 답변은 다음과 같다.

*"상황에 따라 다르다"*

값의 범위만 가지고 short냐 int냐를 결정할 수 없다.

다음 예시를 보자
```
char num1 = 1, num2 = 2; result1 = 0;
short num3 = 1, num4 =2; result2 = 0;

result1 = num1 + num2;
result2 = num3 + num4;

sizeof(result1) //1바이트
sizeof(result2) //2바이트

sizeof(num1+num2) //4바이트
sizeof(num3+num4) //4바이트
```

char형과 short형의 연산 결과가 4바이트를 보이고 있다. 왜 그런것일까?

바로 int형이 CPU성능을 내기 가장 좋은 연산이기때문이다.
그래서 int보다 작은크기의 데이터는 int형 데이터로 바꿔서 연산을 진행한 후, 다시 원래 데이터형에 저장된것이다.

**따라서 연산의 횟수가 빈번한 경우에는 int형을, 데이터의 양이 많아서 연산속도보다 크기를 줄이는 것이 중요하면 char, short를 사용한다고 생각할 수 있다.**

## 실수를 표현 및 처리하기 위한 일반적인 자료형의 선택

실수 자료형의 선택에 있어서 가장 중요한 요소를 정밀도이다.

정밀도란 오차가 발생하지 않는 소수점 이하의 자릿수를 뜻한다.

실수의 오차도 데이터표현에 사용되는 바이트 수가 커지면 줄어든다. 

|실수 자료형|소수점 이하 정밀도|바이트 수|
|:--|:--|:--|
|float| 6자리 | 4 |
|double| 15자리 | 8 |
|long double| 18자리| 12 |

실수 자료형에서 보편적으로 사용하는 자료형은 double이다.  
float보다 정밀도가 높고 long double보다 바이트수가 적기 때문이다.

## unsigned 

정수 자료형의 이름에 한해서 unsigned 선언을 추가하면 0 이상의 값만 표현하는 자료형이 된다.

따라서 표현할 수 있는 값의 범위가 양의 정수 방향으로 두 배 더 넓어지게 된다.  

MSB를 그냥 값의 크기를 나타내는 비트로 사용할수 있기 때문이다.

정수 자료형의 이름 앞에는 signed 선언을 추가할 수 있는데, 이 키워드를 붙인다고 해서 의미가 변하지는 않는다.

즉 int  == signed int 와 동일하다.

*다만 char형은 char == unsigned char 로 처리하는 컴파일러도 있기 때문에 char == signed char라고 생각할수는 없다.
 그래서 char형에 음의 정수를 저장하는 경우에는 signed 선언을 추가하기도 한다.