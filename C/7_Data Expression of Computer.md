# 컴퓨터의 데이터 표현방식
컴퓨터는 2진수를 기반으로 데이터르 표현하고 연산을 진행한다.  
2진수란 2개의 기호를 이용해서 데이터를 표현하는 방식을 가리켜 2진수라 한다.   
10진수는 10개의 기호를 이용하는 것이다.   

지금까지는 23이라는 수를 하나의 수로 인식했을 것이다(물론 하나의 수이다.)  
그러나 지금부터는 2와 3이라는 수의 조합으로 인식하기 바란다. 그래야 혼동을 최소화할 수 있다.  

```
// 0, 1 2진수
// 0~9 10진수
// 0~F 16진수
0 1 2 3 4 5 6 7 8 9 A B C D E F
```
각 진수는 자릿수가 증가하는 시점이 차이가 난다.  

10 진수는 정수 9 다음에 자릿수가 증가한다. 이는 한 자릿수 내에서 표현할 수 있는 최댓값이 9이기 때문이다.  
2 진수는 한 자릿수 내에서 표현할 수 있는 최댓값이 1이기 때문에 1 다음에 자릿수가 증가한다.    

16진수도 이와 같다.  

*16진수를 왜 사용하는 걸까?*
> 컴퓨터는 0 1로만 데이터를 표현한다. 그 길이가 길어질 수록 한눈에 파악하기가 힘들어진다.  
> 그러나 16진수를 사용하면 2진수를 간단하게 표현하고 확인할 수 있다.  
> 2진수 네 개를 16진수 하나로 표현할 수 있기 때문이다.

## 데이터의 표현방식, Bit(비트) 와 Byte(바이트)

비트는 컴퓨터가 표현하는 데이터의 최소단위다. 2진수 값 하나를 저장할 수 있는 메모리의 크기를 뜻한다.   
비트를 여덟개를 묶으면 바이트라는 단위가 된다. 
```
[0] 1비트
[1][0][0][0][0][0][0][0] 1 바이트
```

n개의 비트를 가지고 나타낼 수 있는 데이터의 수는 2<sup>n</sup>개다.
C언어는 10진수 이외에 8진수와 16진수 데이터 표현도 혀용한다.   
따라서 변수 선언 후에 10진수가 아닌, 16진수나 8진수의 표현방식으로 변수에 값을 채울 수도 있다.   

```
int num1 = 10; //특별한 선언이 없으면 10진수
int num2 = 0xA; //0x로 시작하면 16진수로 인식
int num3 = 012; //0으로 시작하면 8진수로 인식
```

표현 방식이 다르다고 해서 저장되는 값이 다른 것은 아니다.  
16진수의 A, 8진수의 12 모두 10진수의 10과 동일한 값이다.  

컴퓨터는 데이터를 2진수 형태로 저장하기 때문에 변수에 초기화 되는 값은 동일하다.

## 정수와 실수의 표현방식

컴퓨터는 어떻게 정수, 실수 그리고 문자를 2진수로 어떻게 표현할까?

### 정수의 표현방식

정수와 실수, 문자를 표현하는 방식에는 큰 차이가 있다.  
먼저 정수의 표현방식에 대해서 알아보자.

c언어는 보통 정수를 4바이트로 표현하지만, 1바이트를 기준으로 표현방식을 설명한다. 큰 차이는 없다.

**정수의 가장 왼쪽에 존재하는 비트는 부호비트이다.**
컴퓨터가 1바이트 메모리 공간에 정수를 저장하려 한다. 그런데 저장하려는 값이 +1이다. 
그렇다면 메모리 공간은 어떻게 채워질까?

```
//맨 왼쪽은 +, - 의 표현
[0][0][0][0][0][0][0][1] 
```

정수에서 가장 왼쪽에 존재하는 비트는 0이면 양수, 1이면 음수로 저장한다.  
이 비트를 가리켜 MSB라고 하는데, 이는  Most Significant Bit의 약자로 가장 중요한 비트라는 뜻을 가지고 있다.  
가장 왼쪽 비티를 제외한 나머지 비트들은 데이터의 크기를 나타낸다. 위 그림의 경우, 나머지 일곱 비트가 0000001 이므로 1이라는 크기를 나타낸다.

MSB가 0이고 크기가 1이므로 +1을 의미하는 1바이트가 만들어졌다.

음의 정수는 어떻게 표현할까?

**음의 정수를 표현할 때에는 2의 보수를 취해야한다.**

MSB만 바꿔주면 되는게 아닌가라고 생각한다면 이는 잘못된 생각이다.

MSB만 바꿀시 다음과 같은 결과가 나온다

```
 [0][0][0][0][0][0][0][1]  // 1 
+[1][0][0][0][0][0][0][1]  //-1 을 MSB만 바꿔 표현한 것
-------------------------
 [1][0][0][0][0][0][1][0] //합산 결과는 130
```
1 + (-1)은 0이 나와야 정상인데 위와 같은 결과가 나오게된다.

따라서 음의 정수를 표현할 때는 1의 보수를 취하고 1을 더하는 **2의 보수법**을 취하는 것이다.  
음의 보수법을 사용해서 -1을 표현하면 다음과 같다.

```
 [0][0][0][0][0][0][0][1]  // 1 
 [1][1][1][1][1][1][1][0]  // 1의 보수를 취함
 [1][1][1][1][1][1][1][1]  // 1을 더함 <- 정수 -1 완성
```

2의 보수법으로 만든 음의 정수를 양의 정수와 다시 계산해 보자.

```
 [0][0][0][0][0][0][0][1]  // 1 
+[1][1][1][1][1][1][1][1]  //-1 
-------------------------
 (1)[0][0][0][0][0][0][0][0] //올림수는 버려지고 합산 결과는 0
```

따라서 음수는 2의 보수법으로 표현하는 것이 적절하다는 것을 알 수 있다.

## 실수의 표현방식

실수를 표현하는 방식은 조금 복잡하다.  
2 바이트 메모리를 가지고 소수점 이하의 값을 갖는 실수의 표현 방식을 나름대로 상상해보자.  
가장 쉽게 생각할 수 있는 방식은 다음과 같다.  

*2 바이트를 반으로 나눈뒤, 반은 소수점 이상, 나머지는 소수점 이하를 표시하기*

```
//소수점 이상            //소수점 이하
[0][0][0][0][0][0][0][1] [0][0][0][0][0][1][0][0]
```

위 표현은 잘못되었다.  
위 표현방식으로 실수를 정의하게 된다면 2바이트를 가지고 나타낼 수 있는 실수의 수가 너무적어 우리에게 필요한 충분한 범위의 실수를 표현하지 못한다.   
27123.012312같은 식을 표현하려면 대체 몇 바이트가 소모될 것인가?   
따라서 넓은 범위의 실수를 적은 비트 수를 가지고 표현하기 위해 수식이 하나 정의되어있다. 

# +-(1.m) x 2<sup>e-127</sup>

```
//(맨왼쪽은 부호표현)
[0][0][0][0][0][0][0][1]<- e [0][0][0][0][0][1][0][0]<- m
```
컴퓨터는 이러한 형식의 식을 미리 정의 해 놓고, 메모리에 할당된 데이터의 일부 비트는 m의 값을, 일부는 e의 값을 정하는데 사용하는 방식으로 실수를 표현하고 있다.

**하지만 단점도 존재하는데, 넓은 범위의 실수를 표현할 수 있지만, 실수 표현에 오차가 존재한다."**

오차가 존재하는 이유는 무엇일까?  
위에 정의 된 수식으로는 모든 실수를 정확히 표현할 수 없기 때문이다.

간단한 예를 들자면, 0.0을 위 수식으로 만들 수 있는가? 2의 n승은 0이 될수 없기때문에 불가능하다.

이렇듯 컴퓨터는 실수의 값을 정확하게 표현하는 것이 아니라, 아주 아주 가까운, 문제가 없을 만큼의 근사치를 통해서 실수를 표현하게 된다.

따라서 실수를 표현하는데 오차가 존재하는 것은 당연하며, 이런 오차를 **부동 소수점 오차**라고 한다.

다음과 같이 간단한 코드로 이를 확인할 수 있다.
```
#include<stdio.h>

int main(){
    int i;
    float num = 0.0;

    for(i = 0; i<100; i ++)
        num += 0.1;
    
    printf("%f", num);
    return (0);
}

//예상 결과 = 10 실제 결과 = 10.000002
```

부동 소수점 오타는 비단 C언어만의 문제가 아니라 컴퓨터의 실수 표현의 한계이기때문에  
다른 프로그래밍 언어에도 존재하는 문제다.