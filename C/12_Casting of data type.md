# 자료형의 변환

char형으로 표현되어 있는 데이터의 표현방식을 int형으로 바꾸거나, int형 데이터를 double형으로 바꾸는 것이  
자료형의 변환이다.

즉 **자료형의 변환이라는 것은 데이터의 표현방식을 바꾸는 것이다.** 

이러한 자료형의 변환은 다음과 같이 크게 두 종류로 나뉜다.
* 자동 형 변환(묵시적 형 변환)
* 강제 형 변환(명시적 형 변환)

## 대입연산 전달과정에서 발생하는 자동 형 변환

대입 연산자의 왼편과 오른편에 존재하는 두 피연산자의 자료형이 일치하지 않으면, 왼편에 있는 피 연산자를 대상으로 형 변환이 자동으로 일어난다.  
당연하겠지만 저장소의 자료형의 맞춰 형 변환이 일어나야 값의 저장이 가능하기 때문이다.

다음 문장을 보자

```
    double num = 245;
```
이 경우 대입 연산자의 왼편에 있는 num1은 double이지만 245는 int형이다. 따라서 정수형 245은 double형 245.0으로
형변환이 되어 num1에 저장된다.

```
    int num2 = 3.1415;
```
이 경우는 double형이 int형으로 변환되어 들어간다. 그런데 int형으로는 소수점 이하의 값을 표현할 수 없으므로, 형변환 과정에서  
3.1415가 3으로 변환되어 소수부의 손실이 발생한다.  

다음과 같은 경우는 어떻게 형 변환이 진행될까?
```
    int num3 = 129;
    char ch = num3;
```

129가 저장된 변수 num3의 비트열은 다음과 같다.
```
00000000 00000000 00000000 10000001
```

이 데이터를 변수 ch에 저장하기 위해서는 1바이트크기로 줄여야 한다.  
따라서 이 경우에는 **상위 바이트의 손실**이 발생한다.

```
10000001 //음수 이므로 2의 보수를 취하면 01111111, 즉 -127을 의미한다.
```

이렇듯 상위 바이트의 손실로 인해 부호가 바뀌는 경우도 있으니 주의해야한다.

대표적인 형변환을 정리하면 다음과 같다.

1. 정수를 실수로 형 변환하는 경우
    실수의 표현범위가 정수에 비해 넓기 때문에 데이터의 손실은 일어나지 않는다. 다만, 실수이기때문에 오차는 존재한다.
2. 실수를 정수로 형 변환하는 경우
    정수는 소수점 이하를 표현하지 못하기 때문에, 소수점 이하의 값은 버려진다.
3. 바이트가 큰 정수를 바이트가 작은 정수로 형 변환하는 경우
    변환하고자 하는 정수의 바이트 크기에 맞춰 상위 바이트를 단순 소멸시킨다. 이로인해 부호가 바뀔 수 있다.

## 정수의 승격(Integral Promotion)에 의한 자동 형 변환

앞서 다음과 같이 설명한바 있다.

**"일반적으로 CPU가 처리하기 가장 적합한 크기의 정수 자료형을 int로 정의한다. int형 연산의 속도는 다른 자료형의 연산속도에 비해 동일하거나 빠르다."**

따라서 int보다 작은 크기의 정수형 데이터는 int형으로 변환이 되어 연산이 진행된다고 했다.  
다음과 같은 경우에도 int형으로 자동 형 변환이 발생한다.  
```
    short num1 = 15, num2 = 25;
    short num3 = num1 + num2; //num1, num2가 int로 형 변환
```
이러한 형태의 번환을 가리켜 정수의 승격 (Integral Promotion)이라 한다. 그런데 위에는 정수의 승격만 일어난 것이 아니다.  
num1과 num2의 계산 결과는 int형 정수이기 때문에 대입연산 과정에서 형변환이 한번 더 일어난다.

>오늘날에는 CPU의 성능 및 구조가 개선이 많이 되어 정수형간 연산속도차이가 크지 않다. 하지만 세상에는 많은 종류의 cpu가 있어 정수의 승격은 여전히 의미를 가지고 있다.

## 피연산자의 자료형 불일치로 발생하는 자동 형 변환

사칙연산과 같은 기본적인 산술 연산에는 두개의 피연산자가 필요하다. 이 때 둘의 자료형이 일치해야하며, 불일치시 자동 형 변환이 일어난다.

double num 1 = 5.15 + 19;

정수와 실수는 표현방식이 다르므로 위 연산은 불가능하다. 따라서 형 변환을 진행해야 하는데,

정수형으로 둘다 변환하면 소수부의 손실이 일어나니 실수형으로 변환을 시킨다. (이것이 더 좋은 선택이기 때문이다)

따라서 int -> double 형 변환이 이루어진다.

**피연산자의 자료형이 일치하지 않아서 발생하는 자동 형 변환은 데이터의 손실을 최소화하는 방향으로 진행된다.**
```
 int -> long -> long long -> float -> double -> long double
```

char와 short가 보이지 않는 이유는 둘다 연산과정에서 int형으로 승격되기 때문이다.

*4바이트 크기의 float이 8바이트 long long보다 우선순위가 왜 높을까?*
이는 데이터의 손실 최소화가 기준이기 때문이다. long long이 float으로 변환될 경우 데이터의 손실은 생각만큼 크지 않다. 
표현할 수 있는 값의 범위는 float이 더 넓기 때문이다. 다만 float이 long long이 될경우 100% 손실이 발생하기 때문에 실수형은 항상 정수형보다 우선 변환된다.

## 명시적 형 변환 : 강제로 일으키는 변환

```
#include <stdio.h>

int main()
{
    int num1 = 3, num2 = 4;
    double result;
    result = num1 / num2;
    printf("%f", result);
    return (0);
}
```
위 소스코드의 결과는 0.000000이다.

연산결과의 자료형은 피연산자의 자료형과 일치하기 때문에 정수형 나눗셈 결과의 몫만 출력이 되었다.  
그것을 double형으로 변환하니 0 -> 0.000000이 된것이다.

다만 소스코드를 다음과 같이 변경하면 그 값이 0.75가 나온다.
```
#include <stdio.h>

int main()
{
    int num1 = 3, num2 = 4;
    double result;
    result = (double)num1 / num2;
    printf("%f", result);
    return (0);
}
```
자료형을 이렇게 변환하는 명령을 할때는 ()소괄호를 사용하며, 이 때 사용되는 소괄호를 **형 변환 연산자(type casting operator)**라고 한다. 

다만 이렇게 자동 형 변환이 될 때 명시적으로 표시해주면 코드 분석에 좋다.
```
    int num1 = 3;
    double num2 = 2.5 * (double)num1; //자동 형 변환이 되지만 명시적으로 표시는 해둔 것. 이해하기 좋다.
```